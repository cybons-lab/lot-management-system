# アプリ層 脆弱性検証レポート

## 概要
ユーザー様より指示のあった「破壊テスト」シナリオに基づき、システム（アプリ層）の脆弱性検証を行いました。
その結果、**4件のクリティカルな不具合**と**1件のセキュリティ懸念**を確認しました。
すべての不具合についてReproduction Script（再現スクリプト）を作成し、動作確認済みです。

## 検出された脆弱性一覧

| ID | 重大度 | カテゴリ | 問題の概要 | 影響 |
|----|-------|----------|------------|------|
| V-01 | **High** | 同時実行性 | `confirm`処理のレースコンディション | 1つの予約に対してSAPへの二重発注登録が発生する |
| V-02 | **High** | 整合性 | SAP連携後のDBコミット失敗時のリカバリ不備 | リトライによりSAP側で重複伝票が作成される |
| V-03 | **Medium** | ステート管理 | 確定済み（Shipped/Confirmed）予約の強制キャンセル | SAP側にキャンセル通知されず、商品が出荷されてしまうのにシステム上はキャンセル扱いになる |
| V-04 | **Medium** | 境界値 | 期限切れロットの予約確定が可能 | 品質保証外（期限切れ）の製品を出荷できてしまう |
| V-05 | **Low** | セキュリティ | 権限チェックの欠如 | 誰でもAPI経由で任意の予約をキャンセル可能（要件次第でHigh） |

---

## 1. V-01: 同時実行による二重確定 (Double Confirm)

### 現象
`confirm_reservation` 関数において、DB上の予約ステータスチェックと、実際の確定処理（SAP連携含む）の間にロックの隙間があります。
ほぼ同時のタイミングで2つのリクエストが来た場合、両方とも「未確定」と判断し、SAP連携を2回実行してしまいます。

### 再現方法
`confirm_reservation` を別スレッドで同時に呼び出すスクリプトにより、SAPモックが2回呼ばれることを確認しました。

```python
# backend/app/check_race.py の実行結果
Total SAP Calls: 2
VULNERABILITY CONFIRMED: Double SAP Registration occurred!
```

### 修正案
`LotReservation` レコード自体を `with_for_update()` でロックする必要があります。現在は `Lot` のみをロックしていますが、予約自体のステータス変更を排他制御する必要があります。

---

## 2. V-02: 部分的失敗によるデータ不整合 (Partial Failure)

### 現象
SAPへの登録API呼び出しが成功した後、データベースのコミットまでの間に障害（DB接続断など）が発生すると、
「SAPは登録済み」「DBは未確定」という状態になります。
ユーザーが再度確定ボタンを押すと、SAPへ再度登録リクエストが飛び、二重計上となります。

### 再現方法
DBコミット時に例外を投げるモックを使用し、エラー後のリトライ操作をシミュレーションした結果、SAP呼び出し回数が増加することを確認しました。

```python
# backend/app/check_sap_failure.py の実行結果
[Test] DB Status is active (Correct, rolled back)
[Test] Retrying confirmation...
[Test] SAP called AGAIN on retry.
```

### 修正案
- **べき等性の担保**: SAP連携時に、予約IDなどのユニークキー（Idempotency Key）を送信し、SAP側で重複を弾く仕組みが必要です。
- または、**補償トランザクション**: DBコミット失敗時に、例外ハンドラ内で「SAP取消」APIを呼ぶ（ただしこれも失敗するリスクあり）。
- 推奨は、SAP側インターフェースがべき等性をサポートするか確認することです。

---

## 3. V-03: 確定済み予約の不正キャンセル (State Rollback)

### 現象
SAP連携が完了し `CONFIRMED` ステータスになった予約に対し、キャンセルAPI (`release_reservation`) を呼ぶと、
SAPへのキャンセル通知を行うことなく、DB上のステータスだけを `RELEASED` に変更できてしまいます。

### 再現方法
`CONFIRMED` ステータスの予約を作成し、`release_reservation` を呼び出すと、エラーなく `RELEASED` に遷移しました。

```python
# backend/app/check_cancel_confirmed.py の実行結果
VULNERABILITY CONFIRMED: Confirmed reservation was RELEASED without SAP cancellation check or restriction!
```

### 修正案
- `AllocationStateMachine` の遷移ルールを適用し、`CONFIRMED` からの遷移を検証する。
- もしくは、`CONFIRMED` のキャンセル時は必ずSAPのキャンセルAPI（未実装に見える）を呼ぶロジックを追加する。

---

## 4. V-04: 期限切れロットの引当・確定 (Boundary Value)

### 現象
ロットの有効期限 (`expiry_date`) が過去の日付であっても、APIは警告やエラーを出さずに引当確定 (`confirm`) を通してしまいます。

### 再現方法
有効期限切れのロットデータを作成し、`confirm_reservation` を実行したところ、成功しました。

```python
# backend/app/check_expiry_confirm.py の実行結果
VULNERABILITY CONFIRMED: Expired lot was successfully confirmed!
```

### 修正案
`confirm_reservation` 内で `lot.expiry_date >= today` のチェックを追加する必要があります。

---

## 5. V-05: 権限バイパス (Privilege Bypass)

### 現象
`AllocationsRouter` の各エンドポイントには `Depends(get_db)` 以外の依存関係（権限チェック）が見当たりません。
認証されたユーザーであれば、管理者権限がなくても他人の予約をキャンセルしたり、強制確定したりできる可能性があります。

### 修正案
`Role` ベースのアクセス制御 (RBAC) をルーターに導入してください。

---

## 総評
ご懸念の通り、**正常系は動くが、エッジケースや異常系で壊れる/データ不整合が起きる** 箇所が複数見つかりました。
特に V-01, V-02 は金銭的な不整合（二重発注）につながるリスクがあるため、早急な修正を推奨します。
