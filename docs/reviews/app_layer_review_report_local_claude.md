# アプリ層あら探しレポート

**作成日**: 2025-12-14  
**対象**: backend/app/*, frontend/src/*  
**調査観点**: 整合性、ドメイン境界、トランザクション、監査/履歴、性能、例外、テスト

---

## 指摘一覧

### P1-1: datetime.now() と datetime.utcnow() の混在

| 項目 | 内容 |
|------|------|
| **優先度** | P1: 近い将来事故 |
| **症状** | タイムスタンプがローカルタイム/UTCで不整合。比較時に9時間ずれる可能性。ロック期限判定の誤動作。 |
| **再現/条件** | JST環境でサーバー起動時。`order.lock_expires_at > now` の比較はUTC vs ローカルで9時間差が発生。 |
| **原因** | 統一されていないdatetime生成。サービス層は `datetime.now()`、確認層は `datetime.utcnow()` を使用。 |
| **影響範囲** | `lot_service.py`, `confirm.py`, `orders_router.py`, `adjustment_service.py`, 他32ファイル以上 |
| **修正案** | **最小案**: `datetime.now(UTC)` または `datetime.utcnow()` に統一。**理想案**: `datetime.now(timezone.utc)` をヘルパー関数化し、全箇所で使用。 |
| **破壊的変更** | なし。ただし既存データのタイムスタンプに不整合がある場合、マイグレーションで補正が必要。 |

---

### P1-2: 引当確定時のトランザクション分離レベル問題

| 項目 | 内容 |
|------|------|
| **優先度** | P1: 近い将来事故 |
| **症状** | 同時に2ユーザーが同じロットを引当確定すると、在庫がマイナスになる可能性。 |
| **再現/条件** | 同ロットに対して2リクエストが同時に `/allocations/{id}/confirm` を呼ぶ。 |
| **原因** | `confirm.py` で `with_for_update()` を使用しているが、予約チェックと更新の間に他トランザクションが割り込む可能性。`get_reserved_quantity()` がロック外で実行される。 |
| **影響範囲** | `confirm.py:L74-97`, `stock_calculation.py` |
| **修正案** | **最小案**: `get_reserved_quantity()` の呼び出し位置を `with_for_update()` 後に移動。**理想案**: 楽観的ロック（version列）の導入、または `SELECT ... FOR UPDATE NOWAIT` でデッドロック検知。 |
| **破壊的変更** | なし |

---

### P1-3: deprecated メソッド `update_lot_allocated_quantity` が残存

| 項目 | 内容 |
|------|------|
| **優先度** | P1: 近い将来事故 |
| **症状** | 将来の開発者がdeprecatedメソッドを誤使用し、在庫数量が更新されない。 |
| **再現/条件** | 新機能開発時に `AllocationRepository.update_lot_allocated_quantity()` を呼び出す。 |
| **原因** | メソッドが `pass` で no-op になっているが、インターフェースとして残存。呼び出し側は正常動作を期待。 |
| **影響範囲** | `allocation_repository.py:L165-183` |
| **修正案** | **最小案**: `raise DeprecationWarning` で明確にエラー化。**理想案**: メソッド削除、全呼び出し箇所を `LotReservation` 使用に移行完了を確認。 |
| **破壊的変更** | なし |

---

### P2-1: サービス層での直接 db.commit() パターン

| 項目 | 内容 |
|------|------|
| **優先度** | P2: 負債 |
| **症状** | 複合操作時に部分コミットが発生。ロールバックが不完全になる可能性。 |
| **再現/条件** | サービスAがcommit後、サービスBで例外発生。Aの変更はロールバックされない。 |
| **原因** | 60箇所以上で `self.db.commit()` がサービス層に散在。トランザクション境界がサービス内部で決定されている。 |
| **影響範囲** | `lot_service.py`, `customer_items_service.py`, `forecast_service.py`, 他多数 |
| **修正案** | **最小案**: ドキュメントでトランザクション所有者を明記。**理想案**: Unit of Work パターン導入。ルーター層でトランザクション管理。 |
| **破壊的変更** | 大（アーキテクチャ変更） |

---

### P2-2: InsufficientStockError の二重定義

| 項目 | 内容 |
|------|------|
| **優先度** | P2: 負債 |
| **症状** | 例外クラスのインポート先によって挙動が異なる。`lot_number` 属性の有無が不統一。 |
| **再現/条件** | `domain/errors.py` と `allocations/schemas.py` の両方に `InsufficientStockError` が存在。 |
| **原因** | 異なるタイミングで同名例外が追加され、統合されていない。 |
| **影響範囲** | `domain/errors.py`, `allocations/schemas.py`, ルーター層 |
| **修正案** | **最小案**: どちらかにエイリアスを設定し、一方を正とする。**理想案**: `domain/errors.py` に統一し、`allocations/schemas.py` の定義を削除。 |
| **破壊的変更** | なし（エイリアス方式なら） |

---

### P2-3: VLotDetails ビューの性能リスク

| 項目 | 内容 |
|------|------|
| **優先度** | P2: 負債 |
| **症状** | ロット件数増加時（10万件超）、一覧表示が遅延。N+1ではないが、ビュー自体の計算コストが高い。 |
| **再現/条件** | ロット数が増加し、`lot_reservations` の集計が重くなる。 |
| **原因** | ビュー内で `lot_reservations` からの集計を毎回実行。インデックスはあるが、大量データで遅延。 |
| **影響範囲** | `VLotDetails`, `lot_service.list_lots()` |
| **修正案** | **最小案**: ページネーションを厳格化（limit上限設定）。**理想案**: マテリアライズドビュー化、または `reserved_qty` のキャッシュ列追加。 |
| **破壊的変更** | なし（最小案）/ 中（理想案） |

---

### P2-4: find_active_by_lot_reference の後方互換メソッド

| 項目 | 内容 |
|------|------|
| **優先度** | P2: 負債 |
| **症状** | 古いコードパスで `lot_number` 文字列からlotを検索し、追加クエリ発生。 |
| **再現/条件** | `find_active_by_lot_reference()` が呼ばれると、`lot_number` → `lot_id` の変換で1クエリ追加。 |
| **原因** | `lot_id` ベースへの移行が完了しているが、後方互換メソッドが残存。 |
| **影響範囲** | `allocation_repository.py:L70-83` |
| **修正案** | **最小案**: deprecation warning を追加。**理想案**: 呼び出し元を特定し、`lot_id` ベースに移行後、メソッド削除。 |
| **破壊的変更** | なし |

---

### P2-5: フロントエンド型定義と OpenAPI スキーマの手動同期

| 項目 | 内容 |
|------|------|
| **優先度** | P2: 負債 |
| **症状** | バックエンド変更後にフロントエンドの型定義が古いまま。コンパイルは通るがランタイムエラー。 |
| **再現/条件** | 新しいフィールドをAPIレスポンスに追加した後、フロント型定義を更新し忘れ。 |
| **原因** | OpenAPI から型生成しているが、CI/CDで自動検証がない。 |
| **影響範囲** | `frontend/src/@types/api.d.ts`, 全APIレスポンス型 |
| **修正案** | **最小案**: CIで `npm run generate-types && git diff --exit-code` を追加。**理想案**: PR作成時に型生成を自動実行・コミット。 |
| **破壊的変更** | なし |

---

### P3-1: ロット削除操作の未実装（意図的）

| 項目 | 内容 |
|------|------|
| **優先度** | P3: 好み（確認事項） |
| **症状** | `delete_lot()` が存在するが、既定方針「lotは物理削除しない」と矛盾。 |
| **再現/条件** | 現在は呼び出し箇所なし（推測）。 |
| **原因** | 初期実装時の残骸か、管理者用途か不明。 |
| **影響範囲** | `lot_service.py:L542-549` |
| **修正案** | **最小案**: メソッドに「管理者専用」コメント追加。**理想案**: 使用しないなら削除、または `raise NotImplementedError`。 |
| **破壊的変更** | なし |

---

### P3-2: 案Cの責務分離は守られている（確認結果）

| 項目 | 内容 |
|------|------|
| **優先度** | P3: 確認完了 |
| **症状** | なし（問題なし） |
| **確認結果** | `product_mappings` は `import_service.py` でのみ使用。受注・出荷ドメインからの参照なし。`customer_items` は受注・出荷で使用。境界は守られている。 |

---

## 上位5件のまとめ

| 順位 | ID | タイトル | 優先度 | 影響 |
|------|-----|----------|--------|------|
| 1 | P1-1 | datetime.now() / utcnow() 混在 | P1 | ロック期限誤判定、データ不整合 |
| 2 | P1-2 | 引当確定時の競合制御不足 | P1 | 在庫マイナス発生 |
| 3 | P1-3 | deprecated メソッド残存 | P1 | 将来の誤使用リスク |
| 4 | P2-1 | サービス層 commit パターン | P2 | 部分コミット問題 |
| 5 | P2-2 | InsufficientStockError 二重定義 | P2 | 例外ハンドリング不統一 |

---

## 推奨実行順

1. **P1-1 (datetime統一)**: 影響範囲が広いが、機械的な置換で対応可能。まず共通ヘルパー関数を作成し、段階的に置換。
2. **P1-2 (競合制御)**: `confirm.py` の修正は限定的。`get_reserved_quantity()` の呼び出し位置調整で対応。
3. **P1-3 (deprecated削除)**: 呼び出し元がないことを確認後、メソッド削除。
4. **P2-2 (例外統一)**: エイリアス設定で即時対応可能。
5. **P2-5 (型同期CI)**: CIスクリプト追加。

---

## 参考資料

- [SCHEMA_GUIDE.md](SCHEMA_GUIDE.md) - 責務境界ガイド
- [ADR-003](adr/ADR-003_customer_items_product_mappings.md) - customer_items / product_mappings 責務分離
- [schema_review_report.md](schema_review_report.md) - スキーマレビュー
